title: express.md
date: 2018-07-02 10:49:00
tags: express
categories: Node

---

[TOC]

## 1. 构建基本服务器

* 创建express模块，导出一个函数，执行函数可以返回一个app对象
* app对象里定义 `get` 和 `listen` 两个方法
* get方法用于往路由里添加一条路由规则
* 初始化router对象保存所有的路由
* listen方法用于启动一个HTTP服务器并指定处理函数

### 1.1 测试用例

``` js
const express = require('../index');
const app = express();
app.get('/', function(req, res) {
    res.end('hello');
});
app.listen(3000, function(){
    console.log('Server started on port 3000');
});
```

## 2. 封装Router

* app从字面量变为Application类
* 丰富HTTP请求方法
* 封装Router
* 路径一样的路由整合为一组，引入Layer的概念
* 增加路由控制，支持next方法，并增加错误捕获功能
* 执行Router.handle的时候传入out参数

### 2.1 测试用例

``` js
const express = require('../');
const app = express();
/**
app.get('/',function(req,res,next){
    console.log(1);
    next();
},function(req,res,next){
    console.log(11);
    next();
}).get('/',function(req,res,next){
    console.log(2);
    next();
}).get('/',function(req,res,next){
    console.log(3);
    res.end('ok');
});
app.listen(3000);
**/
//-----------

app.get('/',function(req,res,next){
    console.log(1);
    next('wrong');
},function(req,res,next){
    console.log(11);
    next();
}).get('/',function(req,res,next){
    console.log(2);
    next();
}).get('/',function(req,res,next){
    console.log(3);
    res.end('ok');
}).get('/',function(err,req,res,next){
    res.end('catch: '+err);
});
app.listen(3000);
```

``` js
function Route(path){
    this.path = path;
    this.methods = {};
    this.stack = [];
}

function Layer(path,handler){
    this.path = path;
    this.handler = handler;
    this.regexp = pathToRegexp(this.path,this.keys = []);
}

//route主要跟path有关
proto.route = function (path) {
    const route = new Route(path);
    const layer = new Layer(path, route.dispatch.bind(route));
    layer.route = route;
    this.stack.push(layer);
    return route;
}
methods.forEach(function (method) {
    proto[method] = function (path) {
        //创建路由实例，添加Router Layer,创建时和path有关
        let route = this.route(path);
        //调用路由方法 添加route Layer
        route[method].apply(route, slice.call(arguments, 1));
        return this;
    }
});
```

lib/router/route.js
```js
function Route(path){
    this.path = path;
    this.methods = {};
    this.stack = [];
}

methods.forEach(function(method){
 Route.prototype[method] = function(){
     const handlers = Array.from(arguments);
     for(let i=0;i<handlers.length;i++){
         let layer = new Layer('/',handlers[i]);
         layer.method = method;
         this.stack.push(layer);
     }
     this.methods[method] = true;
     return this;
 }
});
Route.prototype._handles_method = function(method){
 return this.methods[method];
}

Route.prototype.dispatch = function(req,res,out){
 let idx = 0,self=this;
 function next(err){
     if(err){
         return out(err);
     }
     if(idx >= self.stack.length){
         return out(err);
     }
     let layer = self.stack[idx++];
     if(layer.method == req.method.toLowerCase()){
         layer.handle_request(req,res,next);
     }else{
         next();
     }
 }
 next();
}
```

## 3. 实现中间件

* application中添加use方法
* Router变函数
* 抽象出Router方便复用
* Router处理中间件

``` js
const express = require('express');
const app = express();

app.use(function(req,res,next){
    console.log('Ware1:',Date.now());
    next();
});
app.get('/',function(req,res,next){
    res.end('1');
});

const user = express.Router();
user.use(function(req,res,next){
    console.log('Ware2',Date.now());
    next();
});
user.use('/2',function(req,res,next){
    res.end('2');
});
app.use('/user',user);
app.use(function(err,req,res,next){
    res.end('catch '+err);
});
app.listen(3000,function(){
    console.log('server started at port 3000');
});
```

## 4. req.params

- 可以获取 `req.params`
- 提供 `app.param` 的能力
    + layer 借助 `path-to-regexp` 提取params
    + 在Router.handle里，process_params函数一次调用参数处理函数

``` js
const express = require('express');
const app = express();

app.param('uid', function(req, res, next, val, name){
    req.user = {id: 1, name: 'zfpx'};
    next();
})
app.param('uid', function(req, res, next, val, name){
    req.user.name = 'zfpx2';
    next();
});
app.get('/user/:uid', function(req, res){
    console.log(req.user);
    res.end('user');
});
app.listen(3000);
```

## 5. 模板引擎

- 如何开发或绑定一个渲染引擎
- 注册一个渲染引擎
- 指定模板路径
- 渲染模板引擎

app.engine(ext, callback)
    * ext 文件扩展名
    * callback 模板引擎的主函数
        - 文件路径
        - 参数对象
        - 回调函数

### 5.1 测试用例

```js
const express = require('express');
const path = require('path');
const html = require('../lib/html');
const app = express();
const fs = require('fs');

app.engine('html', html);
app.set('views', path.resolve('views'));
app.set('view engine', 'html');
app.get('/', function(req, res, next){
    res.render('index', {title: 'hello', user: {name: 'zfpx'}});
});
app.listen(3000);
```

### 5.2 渲染函数

### 5.3 模板引擎

---

[来源](http://www.zhufengpeixun.cn/plan/html/24.express-3.html)














