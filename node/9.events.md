title: util & events
date: 2018-06-01 17:30:00
category: Node
tags: 
- events
- util 

---

## util

``` js
let util = require('util');
util.inherit(child, parent); // 只能继承公有方法
util.isArray([]);
util.isRegExp(/\d/);
util.idDate(new Date());
util.promisify(fs.readFile);
util.isError(new Error);
util.inspect({name: 'zfpx'});
```

* util.promisify

``` js
// 一
let fs = require('fs');
fs.readFile('./1.txt', 'utf8', callback);

// 二
let fs = require('fs');
let { promisify } = require('util');
let read = promisify(fs.readFile);
read('./1.txt', 'utf8').then(data=>{...},err=>{...})

// 三
let fs = require('fs');
let { promisify } = require('util');
let read = promisify(fs.readFile);
async function r(){
    try{
        let result = await read('./1.txt', 'utf8');
        return result;
    } catch(e){
        // console.log(e)
        throw e;
    }
}
r().then(data=>{...},err=>{...});

```

## 事件

node中的事件模型就是我们常见的订阅发布模式，node核心api都采用异步事件驱动，所有可能触发事件的对象都是一个继承自EventEmitter类的子类实例对象。

简单来说，就是node帮我们实现了一个订阅发布模式

**订阅发布模式(Subscribe/Publish)**

订阅发布模式定义了一种一对多的依赖关系，在Node中EventEmitter对象上开放了一个可以用于监听的on(eventName, callback)函数，允许将一个或多个函数绑定到对应的事件上。当EventEmitter对象触发一个事件时，所有绑定在该事件上的函数都被同步调用。

这种模式在node中被大量使用。例如：流

## events模块

* EventEmitter.on
* EventEmitter.emit
* EventEmitter.removeListener
* EventEmitter.once
* EventEmitter.newListener
* EventEmitter.defaultMaxlisteners // 默认最多注册10个监听器
* EventEmitter.eventNames
* EventEmitter.removeAllListeners
* EventEmitter.prependListener
* EventEmitter.prependOnceListener 



---

[来源](https://zhufengzhufeng.github.io/201802/html/9.NodeCore.html)