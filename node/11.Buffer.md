title: Buffer.md
date: 2018-06-04 13:00:00
tags: Buffer
categories: Node
---

## 1. 什么是Buffer

* 缓冲区Buffer 是暂时存放输入输出数据的一段内存。
* JS语言没有二进制数据类型，而在处理`TCP` 和 `文件流` 的时候，必须要处理二进制数据。
* NodeJS提供了一个Buffer对象来提供对二进制数据的操作
* 是一个表示固定内存分配的全局对象，也就是说要放在缓冲区中的字节数需要提前确定
* Buffer好比一个8位字节元素组成的数值，可以有效的在JavaScript中表示二进制数据 

## 2. 什么是字节

* 字节(Byte)是计算机存储时的一种计量单位，一个字节等于8位二进制数
* 一个位就代表一个0或1，每8个位(bit)组成一个字节(Byte)
* 字节是通过网络传输信息的单位
* 一个字节最大值十进制数是255 `2**8-1;`

## 3. 定义buffer的三种方式

**进制**

* 0b 二进制
* 0o 八进制
* 0x 十六进制

**进制之间转换**

``` js
// 将十进制转换为其它进制字符串
(3).toString(2) // "11" 十进制转二进制
(9).toString(8) // "11" 十进制转八进制
(17).toString(16) // "11" 十进制转十六进制
(33).toString(32) // "11" 十提制转三十二进制

// 将任意进制字符串转换为十进制
parseInt("11", 2); // 3 二进制转十进制
parseInt("77", 8); // 63 八进制转十进制
parseInt("e7", 16); //175 十六进制转十进制
```

**定义buffer的三种方式**

### 3.1 通过长度定义

```js
// 创建一个长度为 6、且用 0 填充的 Buffer。
const buf1 = Buffer.alloc(6); // <Buffer 00 00 00 00 00 00>
// 创建一个长度为 10、且用 0x1 填充的 Buffer。
const buf2 = Buffer.alloc(6, 1); // <Buffer 01 01 01 01 01 01>
// 创建一个长度为 10、且未初始化的 Buffer。
const buf3 = Buffer.allocUnsafe(10);
```

### 3.2 通过数组定义

```js
// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。
const buf4 = Buffer.from([1, 2, 3]); // <Buffer 01 02 03>
```

> 正常情况下为0-255之间

### 3.3 字符串创建(常用)

*node不支持GB2312* 借助第三方包 (编码转换问题)

```js
const buf5 = Buffer.from('zfpx'); // <Buffer 7a 66 70 78>
```

## 4. buffer常用方法

### 4.0 编码转换问题

一般中文编码有GBK和UTF8格式的。如何进行编码转换。
第三方包： iconv-lite 查看相关api，不用死记硬背

> npm install iconv-lite

```js
let fs = require('fs');
let path = require('path');
let iconvLite = require('iconv-lite'); // 这个包需要转化的是buffer
let r = fs.readFileSync(path.resolve(__dirname,'a.txt'));
let result = iconvLite.decode(r,'gbk'); // 进行内容编码的转化
console.log(result); 
```

### 4.0 BOM头的问题 

GB2312 另存为 UTF8 会出现BOM头

```js
let fs = require('fs');
let a = require('./1.encoding')
let path = require('path');
function stripBom(buffer){
  if (Buffer.isBuffer(buffer)){
    if (buffer[0] === 0xef && buffer[1] === 0xbb && buffer[2] === 0xbf) {
      return buffer.slice(3)
    }
  }else{
    if (buffer.charCodeAt(0) === 0xFEFF){
      return buffer.slice(1);
    }
  }
  return buffer
}
let iconvLite = require('iconv-lite'); // 这个包需要转化的是buffer
let r = stripBom(fs.readFileSync(path.resolve(__dirname, 'a.txt'),'utf8'));
console.log(r.toString());
```

### 4.1 fill

    buf.fill(value[, offset[, end]][, encoding])

```js
// 手动初始化，搽干净桌子，将buffer内容清0
buffer.fill(0);
```

### 4.2 write 

    buf.write(string[, offset[, length]][, encoding])

```js
buffer.write('珠', 0, 3, 'utf8');
buffer.write('峰', 3, 3, 'utf8'); // 珠峰
```

### 4.3 writeInt8

```js
var buf = new Buffer(4);
buf.writeInt8(0,0);
buf.writeInt8(16,1);
buf.writeInt8(32,2);
buf.writeInt8(48,3);//16*3*/
console.log(buf);
console.log(buf.readInt8(0));
console.log(buf.readInt8(1));
console.log(buf.readInt8(2));
console.log(buf.readInt8(3));
```

**Litte-Endian & Big-endian**

不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序。

* Big-endian：将高序字节存储在起始地址（高位编址）
* Little-endian：将低序字节存储在起始地址（低位编址）

```js
let buf3 = new Buffer(4);
buf3.writeInt16BE(2**8,0);
console.log(buf3);//<Buffer 01 00 00 00>
console.log(buf3.readInt16BE(0));

buf3.writeInt16LE(2**8,2);
console.log(buf3);//<Buffer 01 00 00 01>
console.log(buf3.readInt16LE(2));
```

### 4.4 toString方法 

    buf.toSring([encoding[, start[, end]]])

```js
buffer.toString('utf8', 3, 6);
```

### 4.5 slice方法

    buf.slice([start[, end]])

```js
let newBuf = buffer.slice(0,4);
```

**截取乱码问题**

```js
let {StringDecoder}  = require('string_decoder');
let sd = new StringDecoder();
// let buffer = new Buffer('珠峰'); // 废弃的方法
let buffer = Buffer.from('珠峰'); // 新方式
console.log(sd.write(buffer.slice(0, 2))); // 此时不是正常汉字，则保存到sd的内部
console.log(sd.write(buffer.slice(2, 6))); // 下次输出时会把上次的结果一同输出

```

### 4.6 copy方法

复制Buffer 把多个buffer拷贝到一个大buffer上

> buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])

``` js
let buf5 = Buffer.from('珠峰培训');
let buf6 = Buffer.alloc(6);
buf5.copy(buf6,0,0,4);
buf5.copy(buf6,3,3,6);
//buf6=珠峰
```

```js
Buffer.prototype.copy2 = function(targetBuffer,targetStart,sourceStart,sourceEnd){
    for(let i=sourceStart;i<sourceEnd;i++){
        target[targetStart+i] = this[i];
    }
};
```

### 4.7 concat方法

> Buffer.concat(list[, totalLength])

```js
let buf1 = Buffer.from('珠');
let buf2 = Buffer.from('峰');
let buf3 = Buffer.concat([buf1,buf2],3);
console.log(buf3.toString());
```

```js
Buffer.concat2 = function (list = [], total = list.reduce((len, item) => len + item.length, 0)) {
    if (list.length == 1)
        return list[0];
    let result = Buffer.alloc(total);
    let pos = 0;
    for (let bf of list) {
        for (let b of bf) {
            if (pos < total)
                result[pos++] = b;
            else
                return result;
        }
    }
    return result;
};

```

```js
Buffer.myConcat = function(list,totalLength=list.reduce((len,item)=>len+item.length,0)){
  if(list.length==0)
    return list[0];
  let newBuffer = Buffer.alloc(totalLength);
  let offset = 0;
  for(let i=0;i<list.length;i++){
    if(offset+list[i].length>totalLength){
      list[i].copy(newBuffer,offset,0,totalLength-offset);
      break;
    }else{
      list[i].copy(newBuffer,offset,0,list[i].length);
      offset+=list[i].length;
    }
  }
  return newBuffer;
};

```

### 4.8 isBuffer

判断是否是buffer

> Buffer.isBuffer

### 4.9 length

获取字节长度(显示是字符串所代表的buffer的长度)

```js
Buffer.byteLength("张三");
buffer.length;

```

## 6. base64

* base64是网络上最常见的用于传输8Bit字节码的编码方式之一，base64就是一种基于64个可打印字符来表示二进制数据的方法。
* base64要求把每三个8Bit的字节转换为四个6bit的字节（38 = 46 = 24），然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1/3

``` js
const CHARTS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
function transfer(str){
  let buf = Buffer.from(str);
  let result = '';
  for(let b of buf){
      result += b.toString(2);
  }
    return result.match(/(\d{6})/g).map(val=>parseInt(val,2)).map(val=>CHARTS[val]).join('');
}
let r = transfer('珠');//54+g
```



---

[来源](https://zhufengzhufeng.github.io/201802/html/11.Buffer.html)